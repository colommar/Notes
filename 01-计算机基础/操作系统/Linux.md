### 问题：Shell 是二进制程序吗？

- 回答：
- Shell 本身不是一个二进制程序，而是一个命令行解释器，通常是由一个二进制程序实现的。Shell 是一个用户与操作系统交互的接口，允许用户输入命令并执行这些命令。它提供了命令解释、脚本执行、文件操作等功能。

- 在大多数 Unix 和 Linux 系统中，常见的 Shell 例如 Bash、Zsh、Fish 等，都是由二进制可执行文件（例如 `bash`、`zsh`）实现的，这些二进制文件是通过编译源代码生成的。

- 因此，Shell 作为程序本身是由二进制代码实现的，但它的核心功能是为用户提供一个命令行界面来执行各种操作系统命令。


### 问：`cat` 是二进制程序吗？

**答**：是的，`cat` 是一个二进制程序。

在 Linux 和类 Unix 系统中，`cat`（concatenate 的缩写）是一个常见的命令行工具，用于将文件内容输出到标准输出。它本身是由 C 语言编写并编译成二进制可执行文件的，通常存储在系统的 `/bin/` 或 `/usr/bin/` 目录中。

例如，可以通过 `which cat` 命令来查看 `cat` 命令的二进制文件路径：

```bash
$ which cat
/bin/cat
```

这个 `/bin/cat` 就是 `cat` 命令的二进制文件，用户通过终端输入 `cat` 命令时，操作系统会加载并执行这个二进制程序。

---

### 问：那我该怎么区分什么是二进制程序，什么命令不是呢？管道是吗？

**答**：在 Linux 和类 Unix 系统中，命令可以大致分为 **二进制程序** 和 **非二进制程序**（如 Shell 内建命令、管道等）。它们的区别在于实现方式和运行时的处理方式。

#### 1. 二进制程序

**答**：二进制程序是通过编译源代码生成的机器代码文件，它们被存储为可执行的二进制文件（如 `.bin`、无扩展名的可执行文件），直接由操作系统加载并执行。

- **特点**：
    
    - 存储位置：通常位于 `/bin/`、`/usr/bin/`、`/sbin/` 等目录。
    - 可执行：它们是直接由操作系统内核加载并执行的。
    - 文件类型：可以使用 `file` 命令来查看文件类型。例如，`cat` 是一个二进制程序，可以用 `file /bin/cat` 查看其信息。
    
    ```bash
    $ file /bin/cat
    /bin/cat: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=xxxxxxx, not stripped
    ```
    
- **例子**：`cat`、`ls`、`cp`、`mkdir`、`ping` 等。
    

---

#### 2. Shell 内建命令（内建命令）

**答**：Shell 内建命令是由 Shell 程序本身提供的命令，这些命令并不是外部可执行的二进制文件，而是内置在 Shell 中，直接由 Shell 解释和执行。

- **特点**：
    
    - 存储位置：这些命令通常不对应某个外部文件，而是 Shell 本身的一部分。
    - 执行方式：Shell 内建命令不需要操作系统加载外部程序，而是由 Shell 直接解析和执行。
    - 查看内建命令：可以使用 `help` 命令查看当前 Shell 的内建命令列表（例如，`help cd` 查看 `cd` 的帮助文档）。
- **例子**：`cd`、`echo`、`exit`、`history`、`pwd` 等。
    

```bash
$ type cd
cd is a shell builtin
```

---

#### 3. 管道

**答**：管道（`|`）不是一个二进制程序，它是 Shell 中的一个特殊操作符，用来将一个命令的标准输出（stdout）传递给另一个命令的标准输入（stdin）。管道是 Shell 的一部分，而不是独立的可执行程序。

- **特点**：
    - Shell 特性：管道是 Shell 的一部分，允许多个命令组合在一起执行。
    - 不需要额外的程序：管道本身不对应某个二进制文件，它是通过 Shell 的机制将命令的输出流和输入流连接起来。

```bash
$ echo "Hello, World!" | tr 'a-z' 'A-Z'
HELLO, WORLD!
```

在这个例子中，`echo` 命令的输出通过管道传递给 `tr` 命令，后者将文本转换为大写。

---

#### 4. 外部命令

**答**：外部命令是指那些在文件系统中存在的程序，通常是二进制程序或脚本文件。这些命令不是内建的，也不是 Shell 的一部分，而是独立的文件，通常位于 `/bin/`、`/usr/bin/` 等目录。

- **例子**：`ls`、`grep`、`awk`、`find` 等外部命令。

这些命令虽然是外部的，但它们通常是可执行的二进制程序，或者是脚本文件，具体取决于实现。

---

#### 如何区分二进制程序与其他命令：

1. **检查文件类型**：使用 `file` 命令查看文件类型。二进制程序通常是 ELF（Linux 下的可执行格式）或 Mach-O（MacOS 下的可执行格式）文件。

```bash
$ file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=xxxxxxx, not stripped
```

2. **使用 `type` 命令**：
    - 如果一个命令是内建命令，`type` 会告诉你它是 Shell 内建命令。

```bash
$ type cd
cd is a shell builtin
```

- 如果一个命令是外部二进制程序，`type` 会显示它的路径。

```bash
$ type ls
ls is /bin/ls
```

3. **查看 `which` 或 `command -v` 输出**：这些命令会返回外部命令的路径，帮助你确定是否是二进制程序。

```bash
$ which ls
/bin/ls
```

4. **管道、重定向等是 Shell 特性**：这些操作符本身不是二进制程序，它们是由 Shell 提供的功能。

---

总结：

- **二进制程序**：是通过编译源代码生成的可执行文件，通常存储在 `/bin/`、`/usr/bin/` 等目录。
- **Shell 内建命令**：这些命令是 Shell 的一部分，不是外部程序，它们直接由 Shell 解释执行。
- **管道**：管道是 Shell 提供的功能，它本身不是一个独立的二进制程序，而是用于连接多个命令的操作符。

通过使用 `type`、`file` 和 `which` 等命令，你可以方便地区分二进制程序和其他类型的命令。


### 问：Shell 的内建命令有哪些？

**答**：Shell 内建命令是指直接由 Shell 解释并执行的命令，它们并不是外部的可执行程序。这些命令通常不依赖于其他文件或程序，而是 Shell 自带的一部分。常见的 Shell 内建命令包括：

1. **文件操作**
    
    - `cd`：改变当前工作目录。
    - `echo`：输出文本或变量的值。
    - `pwd`：显示当前工作目录。
    - `ls`（有时也作为外部命令）：列出目录内容（也可以通过外部命令实现）。
2. **程序控制**
    
    - `exit`：退出当前 Shell。
    - `return`：从一个函数中返回。
    - `wait`：等待后台进程完成。
3. **条件判断**
    
    - `test` 或 `[ ]`：用于判断条件表达式。
    - `if`：执行条件判断语句。
    - `then`：与 `if` 配合使用，指定条件满足时执行的命令。
4. **循环结构**
    
    - `for`：为一组值执行循环操作。
    - `while`：当条件为真时执行循环。
    - `until`：当条件为假时执行循环。
    - `break`：退出当前循环。
    - `continue`：跳过当前循环的剩余部分，进入下一次循环。
5. **流程控制**
    
    - `trap`：设置信号处理器。
    - `exit`：退出 Shell。
    - `alias`：为命令定义别名。
6. **函数**
    
    - `function`：定义一个 Shell 函数。
7. **变量与参数**
    
    - `export`：将环境变量导出到子进程。
    - `readonly`：将变量设置为只读。
    - `unset`：删除变量或函数。
    - `declare` 或 `typeset`：声明变量或函数的类型。
8. **输入输出重定向**
    
    - `>`：输出重定向。
    - `>>`：追加输出重定向。
    - `<`：输入重定向。
    - `2>`：标准错误重定向。
9. **作业控制**
    
    - `bg`：将作业放到后台运行。
    - `fg`：将作业从后台调到前台运行。
    - `jobs`：列出当前 Shell 会话中的作业。
10. **其他**
    
    - `history`：显示命令历史。
    - `source` 或 `.`：执行一个文件中的命令（通常用于脚本）。
    - `umask`：设置默认文件权限掩码。
    - `env`：显示或设置环境变量。
    - `set`：设置或显示 Shell 变量和选项。

---

#### 如何查看当前 Shell 的内建命令？

你可以使用 `help` 或 `compgen` 命令来查看当前 Shell 的内建命令：

- `help`：显示 Shell 内建命令的帮助文档。
    
    ```bash
    help
    ```
    
- `compgen -b`：列出所有内建命令。
    
    ```bash
    compgen -b
    ```
    

---

#### 例子：使用 `type` 命令查看内建命令

```bash
$ type cd
cd is a shell builtin
```

这里 `cd` 是一个内建命令。

---

总结：Shell 内建命令是 Shell 自带的，不依赖于外部二进制程序，直接由 Shell 解释执行。它们包括文件操作、条件判断、循环结构、作业控制等常见功能。

### 问：`file mkdir` 的输出是什么？

**答**：`file mkdir` 命令的输出是：

```bash
mkdir: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3c13e7a6aa236227608ddf762b070aa841f4a8fd, for GNU/Linux 3.2.0, stripped
```

这表示 `mkdir` 是一个 **ELF 格式的二进制可执行文件**，是 **64 位** 的，适用于 x86-64 架构，且使用 **动态链接**，也就是说它依赖其他共享库（例如 `/lib64/ld-linux-x86-64.so.2`）。该文件是 **PIE（Position Independent Executable）** 格式，并且 **已经去除了调试信息**（`stripped`）。

---

### 问：`type ping` 的输出是什么？

**答**：`type ping` 命令的输出是：

```bash
ping is /usr/bin/ping
```

这表示 `ping` 是一个 **外部命令**，并且位于 `/usr/bin/ping` 路径下。它不是 Shell 内建的命令，而是一个独立的可执行程序。

---

### 问：`file` 和 `type` 命令有什么区别？

**答**：`file` 命令和 `type` 命令有不同的作用：

- **`file` 命令**：用于检测文件的 **实际格式**，比如它是一个二进制程序、脚本文件，还是其他类型的文件。它提供关于文件的详细信息，例如文件类型、架构、是否动态链接等。
- **`type` 命令**：用于告诉你指定的命令是 **内建命令** 还是 **外部命令**。它告诉你命令的类型，并且指出命令是否存在于文件系统中作为可执行文件。

---

### 问：为什么 `mkdir` 和 `ping` 的输出会不同？

**答**：这两者的输出不同，是因为：

- `mkdir` 通过 `file` 命令输出的详细信息，表明它是一个 **二进制可执行文件**，存储在文件系统中，并具有动态链接。
- `ping` 通过 `type` 命令输出，表明它是一个 **外部命令**，存在于文件系统中的一个路径 `/usr/bin/ping` 下，不是 Shell 内建命令。

下面是根据你提出的问题，按照一问一答的形式来逐一解答：

---
## jxc面经

**问题 1**：如何打包，压缩一个文件？

**回答**： 在 Linux 中，可以使用以下命令打包和压缩文件：

- 使用 `tar` 命令打包文件：
    
    ```bash
    tar -cvf archive.tar /path/to/directory
    ```
    
- 使用 `tar` 命令打包并压缩文件：
    
    ```bash
    tar -czvf archive.tar.gz /path/to/directory
    ```
    
- 使用 `gzip` 或 `bzip2` 压缩：
    
    ```bash
    gzip archive.tar  # 压缩成 .tar.gz
    bzip2 archive.tar  # 压缩成 .tar.bz2
    ```
    

---

**问题 2**：硬链接和软链接的区别？

**回答**：

- **硬链接**：指向文件的 inode，每个硬链接都指向文件的同一块数据。文件删除时，只有当硬链接计数为 0 时，文件才会被删除。
- **软链接（符号链接）**：是一个指向目标文件路径的文件。软链接可以跨文件系统，而硬链接只能在同一文件系统内。

---

**问题 3**：golang 的编译出来的二进制文件为什么会很大？

**回答**： Go 编译生成的二进制文件通常较大，主要原因是 Go 语言使用了静态链接。这意味着所有的库和依赖都会被直接编译进可执行文件，而不会依赖外部的动态库。因此，二进制文件会包含更多的代码和数据。

---

**问题 4**：静态链接和动态链接的区别？

**回答**：

- **静态链接**：所有依赖的库和文件在编译时被直接嵌入到可执行文件中，生成的文件较大，但运行时无需依赖外部库。
- **动态链接**：程序在运行时加载需要的共享库，依赖外部库，生成的文件较小，运行时需要依赖操作系统提供的动态链接器。

---

**问题 5**：静态链接的好处？

**回答**： 静态链接的好处是生成的程序不依赖外部库，便于在没有相应库的环境中运行，同时减少了库版本不匹配的问题。缺点是文件较大，且更新库时需要重新编译程序。

---

**问题 6**：动态链接的延迟绑定是什么？

**回答**： 动态链接的延迟绑定指的是在程序运行时动态地将程序与共享库中的函数进行链接，而不是在编译时就确定。这样可以减少程序的初始加载时间，并允许程序在运行时更新和替换库。

---

**问题 7**：进程之间的通信是什么？

**回答**： 进程间通信（IPC，Inter-Process Communication）是指不同进程之间传递数据或信息的机制。常见的 IPC 方式有：

- 管道（Pipe）
- 消息队列（Message Queue）
- 共享内存（Shared Memory）
- 信号（Signal）
- 套接字（Socket）

---

**问题 8**：如何知道一个进程的 PID？

**回答**： 可以使用 `ps` 命令或 `top` 命令来查看当前进程的 PID。例如：

```bash
ps aux | grep <process_name>
```

或使用 `pidof`：

```bash
pidof <process_name>
```

---

**问题 9**：你觉得 PID 会存在文件里吗？

**回答**： PID 通常不会直接存在文件中，但在 Linux 系统中，每个进程都会有一个与之关联的目录 `/proc/[pid]/`，其中包含了进程的相关信息。这些信息可以通过读取该目录下的文件来获取进程的状态。

---

**问题 10**：x86 的字节序是什么？

**回答**： x86 架构使用的是 **小端字节序**（Little-endian），即低字节存储在内存的低地址，高字节存储在高地址。

---

**问题 11**：HTTPS 的请求的 header 是加空的吗？

**回答**： HTTPS 请求的 header 本身并不是加密的，而是以明文的形式传输。但 HTTPS 协议会加密传输的整个 HTTP 请求和响应（包括 header 和 body），所以 header 内容在网络上是加密的。

---

**问题 12**：Python 多线程为什么这么慢？

**回答**： Python 的多线程慢通常是由于 **全局解释器锁（GIL）** 限制。GIL 使得同一时刻只有一个线程能执行 Python 字节码，导致多线程在 CPU 密集型任务中的性能提升有限。可以通过多进程或其他并发模型（如 `asyncio`）来解决。

---

**问题 13**：库函数和系统调用的区别？

**回答**：

- **库函数**：是用户空间提供的函数，通常由程序员调用，执行某些常见的功能（例如 `printf`、`malloc` 等）。
- **系统调用**：是操作系统内核提供的接口，用于程序与操作系统进行交互（如文件操作、进程管理等），通常是通过软中断进入内核空间执行。

---

**问题 14**：`cd` 是一个二进制程序吗？

**回答**： `cd` 不是一个二进制程序，而是 Shell 的内建命令。它用于改变当前工作目录，而不需要执行外部的程序。

---

**问题 15**：Shell 是二进制程序吗？

**回答**： Shell 本身是一个二进制程序（如 Bash 是 `/bin/bash`），它是操作系统的一部分，但在 Shell 中运行的命令不一定是二进制程序，可以是内建命令，也可以是外部程序。

---

**问题 16**：如何查看某个程序用的端口？

**回答**： 可以使用以下命令查看程序使用的端口：

```bash
netstat -tuln | grep <program_name>
```

或者：

```bash
lsof -i -P | grep <program_name>
```

这会列出该程序使用的端口。

---