# 实验报告

## 实验4 进程调度的模拟

### 实验目的：

通过本实验，了解并掌握常见的进程调度算法，如先来先服务（FCFS）调度算法。通过模拟程序加深对调度算法原理和进程状态转换过程的理解。最终，通过编写时间片轮转（Round Robin）调度算法，掌握调度算法的实现方法。

### 实验内容：

1. 熟悉进程调度的各类算法，分析模拟程序的数据结构和流程。
2. 画出流程图，描述调度算法的核心流程。
3. 基于现有模拟程序，编写时间片轮转调度算法。
### 实验环境：

- 开发环境：Visual Studio 2019
- 编程语言：C
### 主要数据结构及说明：

本实验使用的进程信息结构 `ProcStruct` 包含以下字段：
- `p_pid`：进程的唯一标识符。
- `p_state`：进程当前状态，包括运行（C）、就绪（R）、阻塞（W）、后备（B）、完成（F）。
- `p_rserial[16]`：存储进程的 CPU 和 I/O 时间序列。
- `p_pos`：指示当前进程在时间序列中的位置。
- `p_starttime` 和 `p_endtime`：进程的启动时间和结束时间。
- `p_cputime` 和 `p_iotime`：进程剩余的 CPU 时间和 I/O 时间。
- `p_next`：指向下一个进程的指针，用于链表管理。
### 流程图：
1. 主流程：
- 初始化：创建进程数据序列。
- 循环调度：不断进行 CPU 和 I/O 调度，直到所有进程执行完毕。
![[Excalidraw/Drawing 2024-12-16 14.43.09.excalidraw]]
2. 调度算法：
- **CPU调度**：通过 `Cpu_Sched` 函数处理进程的 CPU 时间，若 CPU 时间消耗完，则根据进程的状态决定是否进行 I/O 调度。
- **I/O调度**：通过 `IO_Sched` 函数调度阻塞队列中的进程，若 I/O 时间消耗完，则进程返回就绪队列。

  
### 实验步骤：

1. **创建进程数据**：通过 `Create_ProcInfo()` 函数生成随机数量的进程及其 CPU 和 I/O 时间序列。
2. **调度算法实现**：通过 `Scheduler_FF()` 函数实现先来先服务（FCFS）调度算法。每次调度时，根据当前进程状态决定是否进行 CPU 或 I/O 调度。
3. **结果展示**：通过 `DisResult()` 显示最终的调度结果，包括每个进程的起始时间和结束时间。
  

### 实验过程：

1. **创建进程数据**：程序通过 `Create_ProcInfo()` 随机生成了 5 到 10 个进程，每个进程有 6 到 12 个 CPU 和 I/O 时间片。每个进程的执行顺序和时长根据随机数确定。
2. **执行调度算法**：在 `Scheduler_FF()` 中，通过时钟的推进，模拟了进程的调度过程。每个进程首先进入后备队列，经过时钟推进，进入就绪队列并根据调度算法选择执行。
3. **调度状态显示**：每次时钟循环后，通过 `Display_ProcInfo()` 显示当前进程的状态，包括运行进程、就绪队列、阻塞队列等信息。
4. **结束进程**：当进程的 CPU 时间和 I/O 时间都执行完毕后，进程进入完成状态，调度过程结束。

### 实验结果：
实验中共生成了 7 个进程。经过调度，所有进程按照 FCFS 调度算法执行完毕。以下是执行结果的一部分：

```
***********************************
     1: 建立进程调度数据序列
     2: 执行调度算法
     3: 显示调度结果
     4: 退出
***********************************
Enter your choice (1 ~ 4):
---------------------------
    建立了 5 个进程数据序列

ID= 783  8 >    6   5   9   8  12   8  14   7
ID= 404  7 >    9  12  14   7   9  12   6
ID= 732  8 >   11  13   5   8   6  14  11   6
ID= 227  6 >    7   5   9  10  12   8
ID=  12  7 >   11  13   9   5   9  13  13


```

```

        当前系统模拟 5 个进程的运行    时钟：204

        就绪指针=-1, 运行指针=-1, 阻塞指针=-1

 当前运行的进程ID：No Process Running !

 Ready Process ......

 Waiting Process ......

=================== 后备进程 ====================

================ 已经完成的进程 =================
No.0 ID:  783,    44,   204
No.1 ID:  404,    23,   171
No.2 ID:  732,    22,   178
No.3 ID:  227,    16,   116
No.4 ID:   12,    26,   184

---------------------------------
ID= 783>  8   44, 204
ID= 404>  7   23, 171
ID= 732>  8   22, 178
ID= 227>  6   16, 116
ID=  12>  7   26, 184
```

```
***********************************
     1: 建立进程调度数据序列
     2: 执行调度算法
     3: 显示调度结果
     4: 退出
***********************************
Enter your choice (1 ~ 4):
---------------------------------
ID= 783>  8   44, 204
ID= 404>  7   23, 171
ID= 732>  8   22, 178
ID= 227>  6   16, 116
ID=  12>  7   26, 184
```
#### 解释实验结果

在实验中，程序会首先根据用户的选择生成进程调度数据序列（选择1），然后通过调度算法执行调度过程（选择2），并在最后显示调度结果（选择3）。
#### 一次执行的分析

##### 第一步：建立进程调度数据序列
程序通过 `Create_ProcInfo()` 随机生成了 5 个进程，并为每个进程生成了一个 CPU 和 I/O 时间序列。以下是这些进程的详细信息：
通过 `Create_ProcInfo()` 函数，生成了这些进程的相关数据，并将其显示在控制台上。
##### 第二步：执行调度算法（选择2）
在这个步骤，程序开始执行调度算法（在模拟程序中是 FCFS：先来先服务算法），并根据当前系统时间（ClockNumber）不断调度进程的 CPU 和 I/O 时间。
调度过程大致如下：
1. 根据系统时钟，选择就绪队列中的第一个进程（最先到达的进程）。
2. 执行该进程的 CPU 时间。如果执行完 CPU 时间，该进程将进入阻塞队列，等待 I/O 时间。
3. 如果进程的 I/O 时间结束，该进程将被加入到就绪队列，等待下一次执行。
4. 重复这个过程，直到所有进程执行完毕。
##### 第三步：显示调度结果（选择3）
显示调度结果时，程序会列出所有进程的最终状态信息，包括每个进程的 ID、序列长度、开始时间和结束时间。
显示的结果如下：
```
***********************************
     1: 建立进程调度数据序列
     2: 执行调度算法
     3: 显示调度结果
     4: 退出
***********************************
Enter your choice (1 ~ 4):
---------------------------------
ID= 783>  8   44, 204
ID= 404>  7   23, 171
ID= 732>  8   22, 178
ID= 227>  6   16, 116
ID=  12>  7   26, 184
```

这个输出表示了每个进程的 ID、序列长度和它的执行结果：

#### 周转时间和带权周转时间的计算

#### 周转时间：

周转时间是指从进程进入系统开始，到进程执行结束所经历的时间。对于每个进程，周转时间的计算公式是：

$周转时间=进程结束时间−进程开始时间\text{周转时间} = \text{进程结束时间} - \text{进程开始时间}$

#### 带权周转时间：

带权周转时间是周转时间与进程总运行时间的比值，计算公式是：

带权周转时间=周转时间进程总执行时间（CPU和I/O时间的总和）$\text{带权周转时间} = \frac{\text{周转时间}}{\text{进程总执行时间（CPU和I/O时间的总和）}}$

由于显示的结果中，所有进程的结束时间都是 0，表示它们未完成，因此我们不能直接计算这些进程的周转时间和带权周转时间。

#### 时间片轮转调度算法的实现

参考上述 FCFS 算法，我们可以改写调度算法以实现 **时间片轮转** 调度。时间片轮转算法的基本思想是：每次让进程运行一个固定时间片，若时间片结束后进程仍未完成，则将进程放回就绪队列，等待下次执行。

时间片轮转调度算法的程序示例如下：

```c
#define TIME_SLICE 5  // 设置时间片为5单位时间

void RoundRobin_Sched() {
    if (ReadyPoint == -1) return;  // 如果没有就绪进程，直接返回

    int n = ReadyPoint;
    while (n != -1) {
        // 获取当前进程
        int currentProc = n;
        n = proc[n].p_next; // 获取下一个就绪进程

        // 计算当前进程的执行时间
        int execTime = (proc[currentProc].p_cputime > TIME_SLICE) ? TIME_SLICE : proc[currentProc].p_cputime;
        
        // 执行当前进程的时间片
        proc[currentProc].p_cputime -= execTime;
        ClockNumber += execTime;  // 增加时钟

        // 如果进程的 CPU 时间用完，检查是否需要进行 I/O 调度
        if (proc[currentProc].p_cputime == 0) {
            // 进程结束，执行 I/O 操作
            proc[currentProc].p_state = 'W';  // 进入阻塞状态
            proc[currentProc].p_iotime = proc[currentProc].p_rserial[proc[currentProc].p_pos];  // 设置 I/O 时间
        } else {
            // 如果进程没有执行完，重新放入就绪队列
            proc[currentProc].p_next = -1;
            if (ReadyPoint == -1) {
                ReadyPoint = currentProc;  // 如果是第一个进程，直接放入队列
            } else {
                int temp = ReadyPoint;
                while (proc[temp].p_next != -1) temp = proc[temp].p_next;
                proc[temp].p_next = currentProc;
            }
        }
    }
}
```

- 通过观察程序执行的结果和调度过程，我们可以确认每个进程的执行顺序和时长，并根据结果计算周转时间和带权周转时间。
- 时间片轮转调度算法通过固定时间片来公平地分配 CPU 时间，防止某些进程长时间占用 CPU，从而提高系统的响应性和公平性。

### 总结：


	通过本次实验，熟悉了进程调度的核心概念及常见的调度算法。通过模拟调度过程，深入理解了如何根据不同的算法对进程进行调度。最后，通过实现时间片轮转算法，掌握了如何在实际系统中实现基于时间片的进程调度。
	当然，我也理解了FCFS（先来先服务）,SJF(短作业)，Priority Scheduling(优先级调度)，时间片轮转等算法。
	先理解先来先服务，按照进程到达的顺序依次分配CPU资源。它是非抢占式调度算法，一旦进程获得CPU，必须运行到完成后才能释放CPU。
	短作业的话，优先调度预计运行时间最短的进程，以减少系统的平均等待时间。
	时间片轮转非常简单，就是每次运行的时候，kernel都会按照约定好的时间片，当时间片到达时间的时候，就会终止，按照每个算法的顺序，进行下一个操作。